{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart","text":""},{"location":"#welcome-to-bordertracer","title":"Welcome to BorderTracer","text":"<p>An advanced border-tracing algorithm that generalizes classical image segmentation techniques from pixel-based grids to arbitrary polygonal tilings, enabling contour detection in abstract adjacency graphs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Framework for abstract adjacency graphs</p> <p>The algorithm works for very general adjacency graphs on abstract polygonal tilings. These can be given by Freeman codes, computed from geometric properties of the tiling, or determined directly.</p> </li> <li> <p>Efficient tracing algorithms</p> <p>The algorithms have linear time complexity in the size of the object border. Initialization depends largely on the implementation, but the framework is scalable and versatile.</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"Quick installation<pre><code>!git clone https://github.com/tonamatos/BorderTracer.git\n%cd BorderTracer\nfrom tracing import BorderTracer\n</code></pre>"},{"location":"#examples","title":"Examples","text":"Methods for producing examples<pre><code>from examples.objects import circular_object\nfrom visualization import plot_tiling\n</code></pre> <p>Tip</p> <p>Click on the tabs below to see the object and its computed border on different tiling graphs.</p> 4-adjacent squares8-adjacent squares3-adjacent triangles6-adjacent hexagons <pre><code>from examples.rectangular import RectangularTilingGraph\n\n# Create tiling and object\nG = RectangularTilingGraph()\nG.create_adjacencies(adjacency=\"4-adj\")\nC = circular_object(G)\n\n# Apply the tracing algorithm\nbd = BorderTracer(G, C)\nresult = bd.trace_border()\nG.highlight(result, color=\"indianred\")\nplot_tiling(G)\n</code></pre> <p></p> <pre><code>from examples.rectangular import RectangularTilingGraph\n\n# Create tiling and object\nG = RectangularTilingGraph()\nG.create_adjacencies(adjacency=\"8-adj\")\nC = circular_object(G)\n\n# Apply the tracing algorithm\nbd = BorderTracer(G, C)\nresult = bd.trace_border()\nG.highlight(result, color=\"indianred\")\nplot_tiling(G)\n</code></pre> <p></p> <pre><code>from examples.triangular import TriangularTilingGraph\n\n# Create tiling and object\nG = RectangularTilingGraph()\nG.create_adjacencies(adjacency=\"3-adj\")\nC = circular_object(G)\n\n# Apply the tracing algorithm\nbd = BorderTracer(G, C)\nresult = bd.trace_border()\nG.highlight(result, color=\"indianred\")\nplot_tiling(G)\n</code></pre> <p></p> <pre><code>from examples.hexagonal import HexagonalTilingGraph\n\n# Create tiling and object\nG = RectangularTilingGraph()\nG.create_adjacencies(adjacency=\"6-adj\")\nC = circular_object(G)\n\n# Apply the tracing algorithm\nbd = BorderTracer(G, C)\nresult = bd.trace_border()\nG.highlight(result, color=\"indianred\")\nplot_tiling(G)\n</code></pre> <p></p>"},{"location":"#theoretical-background","title":"Theoretical background","text":"<p>Border tracing is an important segmentation method for two-dimensional digital image processing which determines the frontiers of objects. Boundary tracing algorithms are commonly first formulated for binary images where the object points have a special value in the image, while all other points, called background points, have another value. These algorithms are later combined with methods of object detection, such as filtering, edge detection or texture recognition. The boundary of an object is expected to separate the object from the background, a contour is commonly a path of boundary elements.</p> <p>The generalization from square pixels, which constitute the standard for 2D digital images, to polygonal tiles is justified by the notable attention that polygonal tilings, particularly rectangular, triangular and hexagonal tilings, have received for several decades as alternative model to 2D digital images. Such tilings have been employed, for example, to study the preservation of topological properties during thinning. Rectangular and triangular tilings are special cases of the polygonal tilings used to analyse convexity properties of digital objects and to develop its representation via the minimal perimeter polygon. Triangular and hexagonal pixels have been explicitly employed, for example, in the following:</p> <ul> <li> <p>to develop tools for image processing and image modelling;</p> </li> <li> <p>to design thinning algorithms that preserve topological and geometrical properties of the objects of interest;</p> </li> <li> <p>to perform geometrical transformations, to define geometrical figures such as straight lines or circular arcs, and to study shortest paths;</p> </li> <li> <p>to design digital distance functions with applications in distance transformations employed for skeletonization;</p> </li> <li> <p>special coordinate systems to handle triangular and hexagonal pixels were proposed;</p> </li> <li> <p>triangular pixels were suggested for graphical data visualization; and</p> </li> <li> <p>representations of objects in digital images as unions of polygonal tiles, independently from the \"geometrical form\" of the pixels, can be useful in the classification or recognition of the objects.</p> </li> </ul>"},{"location":"#references","title":"References","text":"<p>This framework was developed by Tonatiuh Matos-Wiederhold as part of the upcoming research paper:</p> <p>Matos-Wiederhold, T., Wiederhold, P., Border tracing in oriented adjacency graphs of polygonal tilings with application to objects made of rectangular, triangular or hexagonal tiles, submitted to Theoretical Computer Science, 2025.</p>"}]}